<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html lang="en">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <title>D★Mark</title>
    <link href="https://fonts.googleapis.com/css?family=Montserrat:700" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Merriweather:400,400italic,700" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Cousine:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="stylesheet.css">
    <meta name="generator" content="Nanoc 4.12.19">
    <meta name="viewport" content="width=device-width, initial-scale=0.5">
  </head>
  <body>
    <h1>D★Mark</h1>
<div class="byline">A project by <a href="https://denisdefreyne.com" rel="author">Denis Defreyne</a>
</div>
<p><b>D★Mark</b> is a language for marking up prose. It facilitates writing semantically meaningful text, without limiting itself to the semantics provided by HTML or Markdown. If you’re a technical writer looking for a flexible markup language, D★Mark might be a good fit.</p>
<p>Here’s an example of D★Mark:</p>
<pre><code><span class="nt">#para</span><span class="err"> This a paragraph; an element in block form containing some text.

</span><span class="nt">#note</span><span class="err">[only=web] This is a note that will </span><span class="nt">%em</span><span class="err">{only} show up on web.</span></code></pre>
<p>For development details on D★Mark, see <a href="https://github.com/denisdefreyne/d-mark">its GitHub repository</a>. Please <a href="https://github.com/denisdefreyne/d-mark/issues/new">open an issue</a> for any problems that you find.</p>
<section id="cheat-sheet"><h2>
<a href="#cheat-sheet" class="permalink">#</a>Cheat sheet</h2>
<p>This cheat sheet covers the common uses of D★Mark. For more details on the syntax, see the <a href="#syntax">Syntax</a> section.</p>
<p>An element is marked up in block form with <code>#</code>, and in inline form with <code>%</code>:</p>
<pre><code><span class="nt">#para</span><span class="err"> It said </span><span class="nt">%quote</span><span class="err">{Destroy all humans!}, I believe.</span></code></pre>
<p>An element in block from can contain elements and/or text by indenting it with two spaces:</p>
<pre><code><span class="nt">#section</span><span class="err">
</span><span class="nt">  #header</span><span class="err"> Example

</span><span class="nt">  #listing</span><span class="err">
    content = File.read(ARGV[0])
    nodes = DMark::Parser.new(content).run</span></code></pre>
<p>Elements, both in block and inline form, can have attributes inside square brackets:</p>
<pre><code><span class="nt">#listing</span><span class="err">[lang=shell]
  $ ls -l</span></code></pre></section><section id="use-cases"><h2>
<a href="#use-cases" class="permalink">#</a>Use cases</h2>
<p>D★Mark is particularly well-suited for some use cases that don’t work well in other markup languages, as they lack the flexibility to express certain ideas.</p>
<section id="first-term"><h3>
<a href="#first-term" class="permalink">#</a>First term</h3>
<p>On the <a href="http://nanoc.ws">Nanoc web site</a>, the first occurrence of a term is marked up using the <code>firstterm</code> element. For example, the first time the term “identifier” is used, it is marked up as <code>%firstterm{identifier}</code>.</p>
<p>When translated into HTML, this element is converted into a span with the class <code>firstterm</code>: <code>&lt;span class="firstterm"&gt;identifier&lt;/span&gt;</code>. The CSS for the <code>firstterm</code> class ensures that it is printed in italics.</p>
<p>Additionally, a term that is marked up as <code>firstterm</code> will end up in the index at the back of the book that is generated from the Nanoc documentation.</p></section><section id="admonitions"><h3>
<a href="#admonitions" class="permalink">#</a>Admonitions</h3>
<p>Admonitions, such as notes, tips, warnings and hints, can be expressed as elements in D★Mark. For example, the Nanoc web site contains the following caution admonition:</p>
<pre><code><span class="nt">#caution</span><span class="err"> This will remove all files and directories that do not correspond to Nanoc items from the output directory.</span></code></pre>
<p>The stylesheet renders this admonition with a red background, and a warning icon, to attract attention. The  D★Mark documentation, which you are looking at now, contains note admonitions. For example:</p>
<div class="note">This is an example note.</div></section><section id="cross-references"><h3>
<a href="#cross-references" class="permalink">#</a>Cross-references</h3>
<p>One way of marking up a hyperlink in D★Mark is to use a <code>a</code> element. For example, the following code snippet represents a hyperlink to the Nanoc web site:</p>
<pre><code><span class="nt">#p</span><span class="err"> I love the design of the </span><span class="nt">%a</span><span class="err">[href=http://nanoc.ws/]{Nanoc web site}.</span></code></pre>
<div class="note">Because D★Mark itself does not prescribe any vocabulary, there is no single right way to mark up hyperlinks. For example, this document uses a <code>link</code> element with a <code>target</code> attribute for hyperlinks, rather than a more traditional <code>a</code> element.</div>
<p>The Nanoc documentation, however, does not use hyperlinks to link to other pages. While hyperlinks work well on the web, they are more cumbersome to use in print. Because a (distant) goal of the Nanoc documentation is to be readily convertible into a print book, it uses cross-references instead.</p>
<p>A reference is marked up using a <code>ref</code> element, and points to a chapter or section. For example, the following paragraph contains a reference to the Patterns chapter:</p>
<pre><code><span class="nt">#p</span><span class="err"> For more information on patterns, see </span><span class="nt">%ref</span><span class="err">[chapter=/doc/patterns.*]{}.</span></code></pre>
<p>When generating a web version of a document that contains a reference, the reference will be translated into a hyperlink. The name of the chapter is filled in automatically. The above example could be rendered as follows:</p>
<blockquote><p>For more information on patterns, see the <a href="#">Patterns</a> page.</p></blockquote>
<p>In print, however, the reference is translated into the name of the chapter, along with the page number. Additionally, rather than referring to the Patterns <em>page</em>, it refers to the Patterns <em>chapter</em>, in order to prevent confusion between web pages and print pages. For example:</p>
<blockquote><p>For more information on patterns, see the Patterns chapter on page 87.</p></blockquote>
<p>In addition to chapter references, the Nanoc web site also supports references to sections and subsections.</p></section></section><section id="goals"><h2>
<a href="#goals" class="permalink">#</a>Goals</h2>
<dl>
<dt>Be extensible</dt>
<dd>Define only the syntax of the markup language, and don’t bother with semantics. Do not define a vocabulary.</dd>
<dt>Be simple</dt>
<dd>Be easy to write, easy to read, and easy to parse. Be unambiguous. Be easy to syntax highlight.</dd>
<dt>Be compact</dt>
<dd>Introduce as little extra syntax as possible.</dd>
</dl></section><section id="syntax"><h2>
<a href="#syntax" class="permalink">#</a>Syntax</h2>
<p>D★Mark knows two constructs: <span class="firstterm">elements</span> and <span class="firstterm">text</span>. An element has a name, attributes, and wraps elements and/or text in order to give them meaning. Text is just that—text.</p>
<p>An element in D★Mark can take two forms: <span class="firstterm">block-level</span>, and <span class="firstterm">inline</span>.</p>
<dl>
<dt>Block form</dt>
<dd>
<p>An element in block form consists of the <code>#</code> symbol, the name of the element, optionally attributes enclosed in rectangular brackets, a space character, and finally the content. For example:</p>
<pre><code><span class="nt">#para</span><span class="err"> This a paragraph; an element in block form containing some text.

</span><span class="nt">#note</span><span class="err">[only=web] This is an example “note” element with an “only” attribute.</span></code></pre>
</dd>
<dt>Inline form</dt>
<dd>
<p>Inside an element, text can be marked up using elements with the inline form. An element in inline form consists of the <code>%</code> symbol, the name of the element, optionally attributes enclosed in rectangular brackets, and finally the content within braces. For example:</p>
<pre><code><span class="nt">#para</span><span class="err"> I am a paragraph with an </span><span class="nt">%em</span><span class="err">{amazing} inline element.</span></code></pre>
</dd>
</dl>
<p>An element name starts with a letter (lowercase or uppercase), followed by zero or more letters, digits, dashes, or underscores. For instance, <code>em</code>, <code>h2</code>, <code>section-header</code>, <code>SectionHeader</code> and <code>section_header</code> are valid element names, while <code>_section</code>, <code>2</code> and <code>hello/world</code> are not.</p>
<p>At the top level, D★Mark documents consists <em>only</em> of elements in block form.</p>
<p>Elements in block form can be nested. To do so, indent the nested block two spaces deeper than the enclosing block. For example, the following defines a <code>list</code> element with three <code>item</code> elements inside it:</p>
<pre><code><span class="nt">#list</span><span class="err">[unordered]
</span><span class="nt">  #item</span><span class="err"> glob patterns
</span><span class="nt">  #item</span><span class="err"> regular expression patterns
</span><span class="nt">  #item</span><span class="err"> legacy patterns</span></code></pre>
<p>The block element form can also include text on indented lines following the element. In this case, the content is not wrapped inside a nested block-level element. This is particularly useful for source code listing. For example:</p>
<pre><code><span class="nt">#listing</span><span class="err">[lang=ruby]
  identifier = Nanoc::Identifier.new('/about.md')

  identifier.without_ext
  # =&gt; "/about"

  identifier.ext
  # =&gt; "md"</span></code></pre>
<p>An element in block form can always be expressed in inline form and vice versa, with the exception of a top-level element, which always needs to be in block form.</p>
<section id="attributes"><h3>
<a href="#attributes" class="permalink">#</a>Attributes</h3>
<p>Both block and inline elements can also have attributes. Attributes are enclosed in square brackets after the element name, as a comma-separated list of key-value pairs separated by an equal sign. The value part, along with the equal sign, can be omitted, in which case the value will be equal to the key name.</p>
<p>For example:</p>
<ul>
<li><p><code>%code[lang=ruby]{Nanoc::VERSION}</code> is an inline <code>code</code> element with the <code>lang</code> attribute set to <code>ruby</code>.</p></li>
<li><p><code>%only[web]{Refer to the release notes for details.}</code> is an inline <code>only</code> element with the <code>web</code> attribute set to <code>web</code>.</p></li>
<li><p><code>#h2[id=donkey] All about donkeys</code> is a block-level <code>h2</code> element with the <code>id</code> attribute set to <code>donkey</code>.</p></li>
<li><p><code>#p[print] This is a paragraph that only readers of the book will see.</code> is a block-level <code>para</code> element with the <code>print</code> attribute set to <code>print</code>.</p></li>
</ul>
<p>An attribute key starts with a letter (lowercase or uppercase), followed by zero or more letters, digits, dashes, or underscores. For instance, <code>lang</code>, <code>only-for</code>, <code>Audience</code> and <code>data_type</code> are valid attribute keys, while <code>-except</code> and <code>hello/world</code> are not.</p></section><section id="escaping"><h3>
<a href="#escaping" class="permalink">#</a>Escaping</h3>
<p>The following characters need to be escaped:</p>
<ul>
<li><code>}</code></li>
<li><code>%</code></li>
<li>
<code>#</code> (only at the beginning of a block)</li>
<li>
<code>,</code> (only within attribute values)</li>
<li>
<code>]</code> (only within attribute values)</li>
</ul>
<p>To escape a character, prefix it with <code>%</code>.</p>
<p>The following is an example of escaping inline content:</p>
<pre><code><span class="nt">#p</span><span class="err"> To escape a character, prefix it with </span><span class="nt">%code</span><span class="err">{%%}.</span></code></pre>
<p>The following is a listing element containing escaped D★Mark:</p>
<pre><code><span class="nt">#listing</span><span class="err">
  %#para This is a paragraph element in block form.</span></code></pre>
<p>Here’s an example of escaped characters in an attribute value:</p>
<pre><code><span class="nt">#para</span><span class="err">[kind=joke%, ha ha] They say 20%% of all statistics are made up.</span></code></pre></section></section><section id="comparison-with-other-languages"><h2>
<a href="#comparison-with-other-languages" class="permalink">#</a>Comparison with other languages</h2>
<p>D★Mark takes inspiration from a variety of other languages.</p>
<dl>
<dt>HTML</dt>
<dd>
<p>HTML is syntactically unambiguous, but comparatively more verbose than other languages. It also prescribes only a small set of elements, which makes it awkward to use for prose that requires more thorough markup. It is possible use <code>span</code> or <code>div</code> elements with custom classes, but this approach turns an already verbose language into something even more verbose.</p>
<pre><code><span class="nt">&lt;p&gt;</span>A glob pattern that matches every item is <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">"pattern attr-kind-glob"</span><span class="nt">&gt;</span>/**/*<span class="nt">&lt;/span&gt;</span>.<span class="nt">&lt;/p&gt;</span></code></pre>
<pre><code><span class="nt">#para</span><span class="err"> A glob pattern that matches every item is </span><span class="nt">%pattern</span><span class="err">[glob]{/**/*}.</span></code></pre>
</dd>
<dt>XML</dt>
<dd>
<p>Similar to HTML, with the major difference that XML does not prescribe a set of elements.</p>
<pre><code><span class="nt">&lt;para&gt;</span>A glob pattern that matches every item is <span class="nt">&lt;pattern</span> <span class="na">kind=</span><span class="s">"glob"</span><span class="nt">&gt;</span>/**/*<span class="nt">&lt;/pattern&gt;</span>.<span class="nt">&lt;/para&gt;</span></code></pre>
<pre><code><span class="nt">#para</span><span class="err"> A glob pattern that matches every item is </span><span class="nt">%pattern</span><span class="err">[glob]{/**/*}.</span></code></pre>
</dd>
<dt>Markdown</dt>
<dd>
<p>Markdown has a compact syntax, but is complex and ambiguous, as evidenced by the many different mutually incompatible implementations. It prescribes a small set of elements (smaller even than HTML). It supports embedding raw HTML, which in theory makes it possible to combine the best of both worlds, but in practice leads to markup that is harder to read than either Markdown or HTML separately, and occasionally trips up the parser and syntax highlighter.</p>
<pre><code>A glob pattern that matches every item is <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">"pattern attr-kind-glob"</span><span class="nt">&gt;</span>/<span class="ge">**</span>/<span class="err">*</span><span class="nt">&lt;/span&gt;</span>.</code></pre>
<pre><code><span class="nt">#para</span><span class="err"> A glob pattern that matches every item is </span><span class="nt">%pattern</span><span class="err">[glob]{/**/*}.</span></code></pre>
</dd>
<dt>AsciiDoc</dt>
<dd>
<p>AsciiDoc, along with its AsciiDoctor variant, are syntactically unambiguous, but complex languages. They prescribe a comparatively large set of elements which translates well to DocBook and HTML. They do not support custom markup or embedding raw HTML, which makes them harder to use for prose that requires more complex markup.</p>
<div class="note">There is no AsciiDoc example, as this example cannot be represented with AsciiDoc.</div>
</dd>
<dt>TeX, LaTeX</dt>
<dd>
<p>TeX is a turing-complete programming language, as opposed to a markup language, intended for typesetting. This makes it impractical for using it as the source for converting it to other formats. Its syntax is simple and compact, and served as an inspiration for D★Mark.</p>
<pre><code>A glob pattern that matches every item is <span class="k">\pattern</span><span class="na">[glob]</span><span class="p">{</span>/**/*<span class="p">}</span>.</code></pre>
<pre><code><span class="nt">#para</span><span class="err"> A glob pattern that matches every item is </span><span class="nt">%pattern</span><span class="err">[glob]{/**/*}.</span></code></pre>
</dd>
<dt>JSON, YAML</dt>
<dd>
<p>JSON and YAML are data interchange formats rather than markup languages, and thus are not well-suited for marking up prose.</p>
<pre><code><span class="p">[</span><span class="w">
  </span><span class="s2">"A glob pattern that matches every item is "</span><span class="p">,</span><span class="w">
  </span><span class="p">[</span><span class="s2">"pattern"</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nl">"kind"</span><span class="p">:</span><span class="w"> </span><span class="s2">"glob"</span><span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="s2">"/**/*"</span><span class="p">]],</span><span class="w">
  </span><span class="s2">"."</span><span class="w">
</span><span class="p">]</span></code></pre>
<pre><code><span class="nt">#para</span><span class="err"> A glob pattern that matches every item is </span><span class="nt">%pattern</span><span class="err">[glob]{/**/*}.</span></code></pre>
</dd>
</dl></section><section id="samples"><h2>
<a href="#samples" class="permalink">#</a>Samples</h2>
<p>The <span class="filename">samples/</span> directory contains some sample D★Mark files. They can be processed by invoking the appropriate script with the same filename. For example:</p>
<pre><code><span class="prompt">%</span> <kbd>bundle exec ruby samples/trivial.rb</kbd>
&lt;p&gt;I’m a &lt;em&gt;trivial&lt;/em&gt; example!&lt;/p&gt;</code></pre></section><section id="programmatic-usage"><h2>
<a href="#programmatic-usage" class="permalink">#</a>Programmatic usage</h2>
<p>Handling a D★Mark file consists of two stages: parsing and translating.</p>
<p>The parsing stage converts text into a list of nodes. Construct a parser with the tokens as input, and call <code>#run</code> to get the list of nodes.</p>
<pre><code><span class="n">content</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="no">ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">nodes</span> <span class="o">=</span> <span class="no">DMark</span><span class="o">::</span><span class="no">Parser</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">content</span><span class="p">).</span><span class="nf">run</span></code></pre>
<p>Translating means converting the list of nodes into something else. For example, the translation step could translate each element into HTML or LaTeX.</p>
<p>D★Mark does not come with any translators. It does, however, provide a class named <code>DMark::Translator</code>, which is intended as the base class for translators.</p>
<p>For example, the following translator will convert the tree into XML:</p>
<pre><code><span class="k">class</span> <span class="nc">MyXMLLikeTranslator</span> <span class="o">&lt;</span> <span class="no">DMark</span><span class="o">::</span><span class="no">Translator</span>
  <span class="k">def</span> <span class="nf">handle_string</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">_context</span><span class="p">)</span>
    <span class="p">[</span><span class="n">escape</span><span class="p">(</span><span class="n">string</span><span class="p">)]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">handle_element</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">[</span>
      <span class="s2">"&lt;</span><span class="si">#{</span><span class="n">node</span><span class="p">.</span><span class="nf">name</span><span class="si">}</span><span class="s2">&gt;"</span><span class="p">,</span>
      <span class="n">handle_children</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">context</span><span class="p">),</span>
      <span class="s2">"&lt;/</span><span class="si">#{</span><span class="n">node</span><span class="p">.</span><span class="nf">name</span><span class="si">}</span><span class="s2">&gt;"</span><span class="p">,</span>
    <span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">escape</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="n">string</span><span class="p">.</span><span class="nf">gsub</span><span class="p">(</span><span class="s1">'&amp;'</span><span class="p">,</span> <span class="s1">'&amp;amp;'</span><span class="p">).</span><span class="nf">gsub</span><span class="p">(</span><span class="s1">'&lt;'</span><span class="p">,</span> <span class="s1">'&amp;lt;'</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">result</span> <span class="o">=</span> <span class="no">MyXMLLikeTranslator</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
<span class="nb">puts</span> <span class="n">result</span></code></pre>
<p>To create a translator, create a subclass of <code>DMark::Translator</code>, and implement <code>#handle_string</code> and <code>#handle_element</code>, which should return an (optionally nested) array of strings, which will then be joined into a single string after processing.</p>
<dl>
<dt><code>#handle_string(string, context)</code></dt>
<dd>
<p>This function translates strings. The <code>string</code> argument is the string to convert. Typically, this returns an array with the escaped string, e.g. <code>[escape(string)]</code>, where the <code>#escape</code> function performs escaping (such as replacing <code>&amp;</code> and <code>&lt;</code> with <code>&amp;amp;</code> and <code>&amp;lt;</code> in HTML and XML).</p>
<p>The <code>context</code> argument is a hash which is passed through from parent to element. It can be used to change translation logic depending on context. By default, it will be an empty hash.</p>
</dd>
<dt><code>#handle_element(element, context)</code></dt>
<dd>
<p>This function translates elements. The <code>element</code> argument is the element to convert.</p>
<p>The way an element is translated often depends on the element name, <code>element.name</code> (a string), and might depend on the element’s attributes, <code>element.attributes</code> (a hash).</p>
<p>When handling an element, make sure to handle all its child elements. The built-in <code>#handle_children</code> function can be used for this, and is typically called like <code>handle_children(element, context)</code>. Handling child elements does not happen automatically, in order to provide the possibility of conditional output.</p>
<p>Like with <code>#handle_string</code>, the <code>context</code> argument is a hash which is passed through from parent to element.</p>
</dd>
</dl>
<section id="tips-and-tricks"><h3>
<a href="#tips-and-tricks" class="permalink">#</a>Tips and tricks</h3>
<p>The <code>context</code> argument of <code>#handle_element</code> is useful in cases where the resulting output depends on the nesting level. For example, this page uses nested <code>section</code> elements that start with a <code>h</code> (header) element, which is translated to any of the HTML header elements (such as <code>h1</code>) depending on the number of <code>section</code> ancestors:</p>
<pre><code><span class="k">def</span> <span class="nf">handle_element</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
  <span class="k">case</span> <span class="n">element</span><span class="p">.</span><span class="nf">name</span>
  <span class="k">when</span> <span class="s1">'h'</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="ss">:depth</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">[</span>
      <span class="s2">"&lt;h</span><span class="si">#{</span><span class="n">depth</span><span class="si">}</span><span class="s2">&gt;"</span><span class="p">,</span>
      <span class="n">handle_children</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">context</span><span class="p">),</span>
      <span class="s2">"&lt;/h</span><span class="si">#{</span><span class="n">depth</span><span class="si">}</span><span class="s2">&gt;"</span><span class="p">,</span>
    <span class="p">]</span>
  <span class="k">when</span> <span class="s1">'section'</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="ss">:depth</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">[</span>
      <span class="s1">'&lt;section&gt;'</span><span class="p">,</span>
      <span class="n">handle_children</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">context</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="ss">depth: </span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
      <span class="s1">'&lt;/section&gt;'</span><span class="p">,</span>
    <span class="p">]</span>
  <span class="c1"># … handle other elements here …</span></code></pre>
<p>It can be useful to do some further processing on child nodes before returning them. To get a string containing translated child nodes’ content, call <code>#translate</code>, passing in the element’s children, along with the context. Here is an example of this function being used to syntax-highlight source code listings:</p>
<pre><code><span class="k">def</span> <span class="nf">handle_element</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
  <span class="k">case</span> <span class="n">element</span><span class="p">.</span><span class="nf">name</span>
  <span class="k">when</span> <span class="s1">'listing'</span>
    <span class="p">[</span>
      <span class="s1">'&lt;pre&gt;&lt;code&gt;'</span><span class="p">,</span>
      <span class="n">syntax_highlight</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">context</span><span class="p">),</span>
      <span class="s1">'&lt;/code&gt;&lt;/pre&gt;'</span><span class="p">,</span>
    <span class="p">]</span>
  <span class="c1"># … handle other elements here …</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">syntax_highlight</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
  <span class="n">content</span> <span class="o">=</span> <span class="n">translate</span><span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="nf">children</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
  <span class="n">language</span> <span class="o">=</span> <span class="n">element</span><span class="p">.</span><span class="nf">attributes</span><span class="p">[</span><span class="s1">'lang'</span><span class="p">]</span>

  <span class="c1"># … implementation here …</span>
<span class="k">end</span></code></pre>
<p>The <code>context</code> argument can be used to change translation logic for an element based on its parent. For example, strings might be escaped by default, except when they’re inside a <code>listing</code> element, where the strings will be captured and passed into a syntax-highlighting function that expects non-escaped content.</p>
<p>The syntax-highlighting example given above can be modified as follows, for situations where  <code>#syntax_highlight</code> expects unescaped content:</p>
<pre><code><span class="k">def</span> <span class="nf">handle_string</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">context</span><span class="p">[</span><span class="ss">:raw</span><span class="p">]</span>
    <span class="p">[</span><span class="n">string</span><span class="p">]</span>
  <span class="k">else</span>
    <span class="p">[</span><span class="n">html_escape</span><span class="p">(</span><span class="n">string</span><span class="p">)]</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">handle_element</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
  <span class="k">case</span> <span class="n">element</span><span class="p">.</span><span class="nf">name</span>
  <span class="k">when</span> <span class="s1">'listing'</span>
    <span class="p">[</span>
      <span class="s1">'&lt;pre&gt;&lt;code&gt;'</span><span class="p">,</span>
      <span class="n">syntax_highlight</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">context</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="ss">raw: </span><span class="kp">true</span><span class="p">)),</span>
      <span class="s1">'&lt;/code&gt;&lt;/pre&gt;'</span><span class="p">,</span>
    <span class="p">]</span>
  <span class="c1"># … handle other elements here …</span>
<span class="k">end</span></code></pre></section><section id="error-handling"><h3>
<a href="#error-handling" class="permalink">#</a>Error handling</h3>
<p>Parse errors, <code>DMark::Parser::ParserError</code>, implement <code>#fancy_message</code>, which is similar to <code>#message</code> but returns a multi-line string with additional diagnostic information to make it easier to identify and fix errors. For example, the following D★Mark snippet is invalid:</p>
<pre><code><span class="nt">#p</span><span class="err"> Stuff

</span><span class="nt">#p</span><span class="err"> More stuff }</span></code></pre>
<p>… and raises an error, whose <code>#fancy_message</code> returns a string with this content:</p>
<pre><code>parse error at line 3, col 15: unexpected } -- try escaping it as "%}"

#p More stuff }
              ↑</code></pre></section></section>
  </body>
</html>
